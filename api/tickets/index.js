const clientPromise=require('../../lib/mongo');module.exports=async(req,res)=>{const client=await clientPromise;const db=client.db(process.env.DB_NAME||'ticketingDB');const Tickets=db.collection('tickets');if(req.method==='POST'){try{const doc=req.body||{};if(!doc.requester||!doc.department||!doc.description||!doc.urgency){return res.status(400).json({error:'All fields are required.'})}const r=await Tickets.insertOne(doc);return res.status(201).json({_id:String(r.insertedId),ticketId:doc.ticketId})}catch(e){return res.status(500).json({error:e.message})}}if(req.method==='GET'){try{const{q,status,urgency,limit}=req.query;const filter={};if(status)filter.status=status;if(urgency)filter.urgency=urgency;if(q){const esc=q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');const rx=new RegExp(esc,'i');filter.$or=[{requester:rx},{department:rx},{description:rx},{ticketId:rx}]}const lim=Math.min(Math.max(parseInt(limit||'200',10),1),1000);const rows=await Tickets.find(filter).sort({createdAt:-1}).limit(lim).toArray();rows.forEach(r=>r._id=String(r._id));return res.status(200).json(rows)}catch(e){return res.status(500).json({error:e.message})}}res.setHeader('Allow','GET, POST');return res.status(405).json({error:'Method Not Allowed'})};
